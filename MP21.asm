

;$mod186
NAME EG0_COMP

;page 175

;DELAY MACRO 

;ENDM

;IO Setup for 80C188 
	UMCR    EQU    0FFA0H ; Upper Memory Control Register
	LMCR    EQU    0FFA2H ; Lower Memory control Register         
	PCSBA   EQU    0FFA4H ; Peripheral Chip Select Base Address
	MPCS    EQU    0FFA8H ; MMCS and PCS Alter Control Register
	I0CON	EQU	   0FF38H ;INT 0 Control Register -type 12
	I0CON_VAL EQU	00H;priority = 000, msk =1, lvl =0
	IMASK	EQU		0FF28H;
	IMASK_VAL EQU	0EFH; 1110 1111 INT0 unmasked
	EOI	EQU	0FF22H;
	EOI_VAL	EQU	000CH
	PPI8255 EQU 0080H;8255 ADDRESS	
; STACK SEGMENT
STACK_SEG		SEGMENT

	
STACK_SEG		ENDS
	
	
; DATA SEGMENT
DATA_SEG        SEGMENT 
	DD	256	DUP(?) ; INTERRUPTS
	DD	128 DUP(?) ; buffer
	DD	128 DUP(?) ; STACK
	TOS LABEL WORD
	DD	64	DUP(?) ;STACK BUFFER
	requested_floor  db	0H	
	current_floor	db	0AH
	
	
	
DATA_SEG        ENDS


; RESET SEGMENT
Reset_Seg   SEGMENT

    MOV DX, UMCR
    MOV AX, 03E07H
    OUT DX, AX
	JMP far PTR start
	
Reset_Seg  ends


; MESSAGE SEGMENT
MESSAGE_SEG     SEGMENT


MESSAGE_SEG     ENDS

;CODE SEGMENT
CODE_SEG        SEGMENT
       
PUBLIC	START

ASSUME  CS:CODE_SEG, DS:DATA_SEG, SS:DATA_SEG


START:

; Initialize MPCS to MAP peripheral to IO address space
	MOV DX, MPCS
	MOV AX, 0083H
	OUT DX, AX

; PCSBA initial, set the parallel port start from 00H
	MOV DX, PCSBA
	MOV AX, 0003H ; Peripheral starting address 00H no READY, No Waits
	OUT DX, AX

; Initialize LMCS 
    MOV DX, LMCR
    MOV AX, 01C4H  ; Starting address 1FFFH, 8K, No waits, last shoud be 5H for 1 waits      
    OUT DX, AX
;INITIALISE INTERRUPT
	MOV DX, I0CON
	MOV AX,I0CON_VAL
	OUT DX,AX
	
	;MOV DX,I0MASK
	;MOV AX,I0MASK_VAL
	;OUT DX,AX
	; YOUR CODE HERE ...
	; GOOD LUCK!
	;initialise 8255
;initialise stack segment
;	MOV AX, STACK_SEG
;	MOV SS,AX
	STI
	MOV AX,DATA_SEG
	MOV DS,AX; MOVES DATASEGMENT TO 0000H
	MOV BX,OFFSET TOS
	MOV SP,BX
	
	MOV AL,082H;1000 0010 VALUE OF CWR
	MOV DX,PPI8255+3; CWR
	OUT DX,AL	
	;initialise INT0;
	MOV DX,OFFSET INT0ISR
	
	INT0VECT EQU 030H;12*4 VALUE OF MEMORY WHERE INTO'S VECTOR IS LOCATED
	
	
	MOV BX,CS
	MOV DI,INT0VECT
	MOV [DI],DX;MOVES CS TO 0000:0030H
	MOV [DI]+2,BX;MOVES INTOISR'S OFFSET TO 0000:0032H
	;mov word ptr cs:[DI], OFFSET INT0ISR
	;MOV WORD PTR CS:[DI+2],
	MOV BL,01;CURRENT FLOOR-TEST VALUE
	MOV BH,09;REQUESTED FLOOR;
INPUT:
	;MOV DX,PPI8255+1;PORTB
	;IN	AL,DX ;AL IS A BCD NO.
	;MOV AH,0FH
	;AND AL,AH ;TOP 4 BITS PULLED DOWN FOR NOW(0-9)
	;MOV BH,AL; REQUESTED FLOOR MOVED TO BH
	
		
OUTPUT:
	mov al,bh
	not al
	mov dx,PPI8255;PORTA
	out dx,al ;REQUESTED FLOOR IN BCD
	
BCDOUTPUT:
	mov al,BL; CURRENT FLOOR TO OUTPUT
	MOV DX,PPI8255+2;PORTC
	OUT DX,AL;OUTPUT THE MOFO
	CMP Bl,Bh
	JL GOUP
	JG GODOWN
	JMP EQUAL
GOUP:
	cli
	mov cl,010000000B
	and cl,al
	 
	mov dx,PPI8255;port A
	out dx,al

	MOV AL,BL
	INC AL
	;DAA
	MOV CL,AL
	AND CL,0FH
	CMP CL,0AH
	JNZ ALRIGHTY
	MOV CH,06
	ADD AL,CH
	
ALRIGHTY:
		
	MOV BL,AL
	
	JMP MOVED
GODOWN:
	cli
	mov al,0FH
	mov dx,PPI8255;port A
	out dx,al

	MOV AL,BL
	DEC AL
	;DAS
	MOV CL,AL
	AND CL,0FH
	CMP CL,0FH ; going down compare last 4 bits with 0
	JNZ ALRIGHTYSUB
	MOV CH,06
	SUB AL,CH
	
ALRIGHTYSUB:
	MOV BL,AL
	JMP MOVED
EQUAL:
	sti 
	
MOVED:
;	DELAY;BITCH HERE
		
	MOV AX,10
ITER:
	MOV CX, 07FFFh;
AGAIN:
	LOOP AGAIN
	DEC AX
	JNZ ITER
	
	JMP INPUT

INT0ISR:
	CLI
	MOV DX,PPI8255+1;PORTB
	IN	AL,DX ;AL IS A BCD NO.
		
	mov cl,04;
	ROL AL,cl
	;MOV AH,0FH
	;AND AL,AH ;TOP 4 BITS PULLED DOWN FOR NOW(0-9)
	MOV BH,AL; REQUESTED FLOOR MOVED TO BH
	MOV DX,EOI
	MOV AX,EOI_VAL
	OUT DX,AX
	STI
	IRET



CODE_SEG        ENDS
END 
